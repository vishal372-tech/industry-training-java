# Abstract Class Example: Bank Accounts in Java

This example demonstrates the use of an **abstract class** in Java to model different types of bank accounts. It shows how common data and behavior can be defined in a base class, while specific logic is implemented by derived classes.

---

## Problem Overview

We want to model different bank account types:

* A generic `Account` that holds common details.
* A `FixDeposit` account that calculates interest based on principal, rate, and duration.
* A `RecurringDeposit` account that calculates interest based on monthly deposits.

Each account type calculates interest differently, so the interest calculation is kept **abstract** in the base class.

---

## Source Code

```java
abstract class Account {
    String AccountHolder;
    int PrincipalAmt;

    Account(String AccountHolder, int PrincipalAmt) {
        this.AccountHolder = AccountHolder;
        this.PrincipalAmt = PrincipalAmt;
    }

    abstract double calculateInterest();
}

class FixDeposit extends Account {
    int RateOfInterest;
    int Duration;

    FixDeposit(String AccountHolder, int PrincipalAmt, int RateOfInterest, int Duration) {
        super(AccountHolder, PrincipalAmt);
        this.RateOfInterest = RateOfInterest;
        this.Duration = Duration;
    }

    double calculateInterest() {
        return (PrincipalAmt * RateOfInterest * Duration) / 100;
    }
}

class RecurringDeposit extends Account {
    int MaturityAmt;
    int Duration;
    int RateOfInterest;
    int MonthlyDeposit;

    RecurringDeposit(String AccountHolder, int PrincipalAmt, int Duration, int RateOfInterest, int MonthlyDeposit) {
        super(AccountHolder, PrincipalAmt);
        this.Duration = Duration;
        this.RateOfInterest = RateOfInterest;
        this.MonthlyDeposit = MonthlyDeposit;
        this.MaturityAmt = MonthlyDeposit * Duration;
    }

    double calculateInterest() {
        return (MaturityAmt * Duration * RateOfInterest) / 1200;
    }
}

class Main {
    public static void main(String[] args) {
        FixDeposit cus1 = new FixDeposit("Vishal", 1000, 12, 12);
        System.out.println(cus1.calculateInterest());

        RecurringDeposit cus2 = new RecurringDeposit("Chaman", 1000, 12, 12, 100);
        System.out.println(cus2.calculateInterest());
    }
}
```

---

## Explanation

### 1. `Account` (Abstract Class)

* Stores common data such as `AccountHolder` and `PrincipalAmt`.
* Contains an **abstract method** `calculateInterest()`.
* Cannot be instantiated directly.

### 2. `FixDeposit` Class

* Extends `Account`.
* Adds `RateOfInterest` and `Duration`.
* Provides its own implementation of `calculateInterest()`.

### 3. `RecurringDeposit` Class

* Extends `Account`.
* Calculates maturity amount using monthly deposits.
* Overrides `calculateInterest()` with its own formula.

### 4. `Main` Class

* Creates objects of both derived classes.
* Demonstrates **runtime polymorphism** by calling `calculateInterest()`.

---

## Output

```
1440.0
144.0
```

---

## Key Concepts Used

* Abstract class
* Constructor chaining using `super`
* Method overriding
* Runtime polymorphism
* Code reuse through inheritance

---

This design is commonly used in real-world applications where multiple subclasses share common structure but differ in behavior.


# Use of `super` Keyword with Constructors in Java

This example demonstrates how the `super` keyword is used in Java to:

* Call the constructor of a parent class
* Access parent class variables from a child class

It also shows how constructor chaining works during object creation.

---

## Source Code

```java
import java.util.*;

class SuperClass {
    int variableA;

    SuperClass() {
        Scanner s = new Scanner(System.in);
        variableA = s.nextInt();
    }
}

class Subclass extends SuperClass {
    int variableB;

    Subclass() {
        super();
        variableB = super.variableA * 2;
    }

    void displayVariables() {
        System.out.println("The value of SuperClass " + super.variableA);
        System.out.println("The value of SubClass " + variableB);
    }
}

class CSE {
    public static void main(String[] args) {
        Subclass obj = new Subclass();
        obj.displayVariables();
    }
}
```

---

## Explanation

### 1. `SuperClass`

* Contains an integer variable `variableA`.
* The constructor reads input from the user using `Scanner`.
* This constructor is automatically executed when a subclass object is created.

### 2. `Subclass`

* Extends `SuperClass`.
* Uses `super()` to explicitly call the parent class constructor.
* Accesses the parent class variable using `super.variableA`.
* Calculates `variableB` as twice the value of `variableA`.

### 3. `CSE` Class

* Contains the `main` method.
* Creates an object of `Subclass`.
* Calls `displayVariables()` to print values from both classes.

---

## Execution Flow

1. `Subclass` object is created.
2. `SuperClass` constructor runs first and takes user input.
3. Control returns to `Subclass` constructor.
4. `variableB` is calculated using the value of `variableA`.
5. Both values are displayed on the console.

---

## Sample Input

```
5
```

## Sample Output

```
The value of SuperClass 5
The value of SubClass 10
```

---

## Key Concepts Used

* Inheritance
* `super` keyword
* Constructor chaining
* Accessing parent class members
* User input using `Scanner`

---

This example clearly illustrates how data flows from a parent class to a child class using inheritance and the `super` keyword.