# Two Sum Problem – Brute Force Approach in Java

This example demonstrates a **simple and intuitive solution** to the classic **Two Sum** problem using a brute force approach. It is commonly used to introduce problem-solving and nested loop logic.

---

## Problem Statement

Given an integer array `nums` and an integer `target`, return the **indices of the two numbers** such that they add up to `target`.

* Each input has **exactly one solution**.
* You may not use the same element twice.
* The order of the returned indices does not matter.

---

## Source Code

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    ans[0] = i;
                    ans[1] = j;
                    return ans;
                }
            }
        }
        return ans;
    }
}
```

---

## Explanation

* Two nested loops are used to check **every possible pair** in the array.
* The outer loop selects the first element.
* The inner loop checks elements after the current index to avoid repetition.
* When the sum equals the target, indices are stored and returned immediately.

---

## Example

**Input:**

```
nums = [2, 7, 11, 15]
target = 9
```

**Output:**

```
[0, 1]
```

---

## Time and Space Complexity

* **Time Complexity:** `O(n²)`
* **Space Complexity:** `O(1)` (excluding output array)

---

## Key Points

* Very easy to understand and implement.
* Inefficient for large input sizes due to quadratic time complexity.
* Useful as a baseline solution before optimization.

---

## Exam Tip

If optimization is not required or constraints are small, the brute force approach is **perfectly acceptable** and easy to explain in exams.

---

This solution is ideal for learning fundamentals before moving to hash-based optimizations.

# Two Sum Problem – Array Indexing Optimization (Safe Bounds)

This solution demonstrates an **optimized approach** to the Two Sum problem using an auxiliary array for constant-time lookups, with proper boundary checks to avoid invalid access.

---

## Problem Statement

Given an integer array `nums` and an integer `target`, return the **indices of two distinct elements** such that their sum equals `target`.

---

## Source Code

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        int n = nums.length;

        int Max = nums[0];
        for (int i = 1; i < n; i++) {
            if (nums[i] > Max)
                Max = nums[i];
        }

        int[] indexArr = new int[Max + 1];
        for (int i = 0; i <= Max; i++) {
            indexArr[i] = -1;
        }

        for (int i = 0; i < n; i++) {
            int idx = nums[i];
            if (indexArr[idx] == -1)
                indexArr[idx] = i;
        }

        for (int i = 0; i < n; i++) {
            int first = nums[i];
            int second = target - first;

            if (second >= 0 && second <= Max && indexArr[second] != -1 && i != indexArr[second]) {
                ans[0] = i;
                ans[1] = indexArr[second];
                break;
            }
        }
        return ans;
    }
}
```

---

## Step-by-Step Explanation

### 1. Find Maximum Value

* The maximum element in `nums` is identified.
* This value decides the size of the helper array.

### 2. Create Helper Array

* `indexArr` stores indices of numbers present in `nums`.
* All values are initialized to `-1` to indicate absence.

### 3. Store Indices

* For each number in `nums`, its index is stored if not already present.

### 4. Search for Complement

* For each element `first`, compute `second = target - first`.
* Check that `second` lies within valid bounds (`0` to `Max`).
* If present and indices are different, the answer is found.

---

## Example

**Input:**

```
nums = [2, 7, 11, 15]
target = 9
```

**Output:**

```
[0, 1]
```

---

## Time and Space Complexity

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(Max)`

---

## Important Constraints

* Works only for **non-negative integers**.
* Memory usage increases if array values are large.
* Faster than brute force, but less flexible than HashMap approach.

---

## Exam Tip

If constraints specify **small non-negative numbers**, this approach is a valid and efficient alternative to nested loops.

---

This solution highlights how careful boundary checks make array-based optimizations safe and efficient.

# Best Time to Buy and Sell Stock – Brute Force Approach in Java

This example demonstrates a **brute force solution** to the classic stock buy-and-sell problem. It focuses on clarity and correctness, making it ideal for understanding the basic logic before optimization.

---

## Problem Statement

You are given an array `prices` where `prices[i]` represents the price of a stock on the `i-th` day.

You want to **maximize your profit** by choosing **one day to buy** and **a later day to sell**.

* You may complete at most one transaction.
* If no profit is possible, return `0`.

---

## Source Code

```java
class Solution {
    public int maxProfit(int[] prices) {
        int Max = 0;
        int n = prices.length;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (prices[j] - prices[i] > Max) {
                    Max = prices[j] - prices[i];
                }
            }
        }
        return Max;
    }
}
```

---

## Explanation

* The outer loop chooses the **buy day** (`i`).
* The inner loop chooses the **sell day** (`j > i`).
* For every valid pair, the profit is calculated as `prices[j] - prices[i]`.
* The maximum profit found so far is stored in `Max`.

This approach checks **all possible buy–sell combinations**.

---

## Example

**Input:**

```
prices = [7, 1, 5, 3, 6, 4]
```

**Output:**

```
5
```

**Explanation:**

* Buy at price `1` (day 2)
* Sell at price `6` (day 5)
* Profit = `6 - 1 = 5`

---

## Time and Space Complexity

* **Time Complexity:** `O(n²)`
* **Space Complexity:** `O(1)`

---

## Key Points

* Very easy to understand and implement.
* Inefficient for large inputs due to nested loops.
* Serves as a baseline solution before optimization.

---

## Exam Tip

If the problem does not require optimization or input size is small, this solution is perfectly acceptable and easy to explain.

---

This brute force method helps build intuition before moving to the optimized single-pass solution.



