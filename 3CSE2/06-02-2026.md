# Move Zeroes – Using Extra Array in Java

This solution demonstrates a **simple and clear approach** to the classic **Move Zeroes** problem by using an auxiliary array. The goal is to move all zeroes to the end while maintaining the relative order of non-zero elements.

---

## Problem Statement

Given an integer array `nums`, move all `0`s to the end of the array **without changing the relative order** of the non-zero elements.

* The operation must be done in-place (final result stored in `nums`).
* Order of non-zero elements must remain the same.

---

## Source Code

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length;
        int[] temp = new int[n];
        int j = 0;

        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                temp[j] = nums[i];
                j++;
            }
        }

        int k = 0;
        for (int i = 0; i < n; i++) {
            if (k == j) {
                nums[i] = 0;
            } else {
                nums[i] = temp[k];
                k++;
            }
        }
    }
}
```

---

## Step-by-Step Explanation

### Step 1: Copy Non-Zero Elements

* Traverse the original array.
* Copy all non-zero elements into a temporary array `temp`.
* Variable `j` tracks the count of non-zero elements.

### Step 2: Rewrite Original Array

* First `j` positions are filled with values from `temp`.
* Remaining positions are filled with `0`.

This ensures that:

* All non-zero elements remain in the same order.
* All zeroes are moved to the end.

---

## Example

**Input:**

```
nums = [0, 1, 0, 3, 12]
```

**Output:**

```
[1, 3, 12, 0, 0]
```

---

## Time and Space Complexity

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(n)` (extra array used)

---

## Key Points

* Very easy to understand and implement.
* Preserves the order of non-zero elements.
* Uses extra space, so it is not the most optimal solution.

---

## Exam Tip

This approach is acceptable when **extra space is allowed**. If the problem explicitly asks for **constant space**, an in-place two-pointer approach should be used instead.

---

This solution is ideal for learning before moving to the optimized in-place method.

# Move Zeroes – In-Place Two Pointer Approach in Java

This solution solves the **Move Zeroes** problem using an **in-place two-pointer technique**, which achieves optimal space complexity while preserving the relative order of non-zero elements.

---

## Problem Statement

Given an integer array `nums`, move all `0`s to the end of the array **without changing the relative order** of the non-zero elements.

* The operation must be done **in-place**.
* No extra array should be used.

---

## Source Code

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int i = 0;
        int n = nums.length;
        int j = 0;

        for (; j < n; j++) {
            if (nums[j] != 0) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
    }
}
```

---

## How the Algorithm Works

### Pointer Roles

* `i` → Tracks the position where the next non-zero element should be placed.
* `j` → Scans through the array.

---

### Step-by-Step Logic

1. Initialize both pointers at the start of the array.
2. Traverse the array using pointer `j`.
3. When a non-zero element is found:

   * Swap it with the element at index `i`.
   * Increment `i`.
4. Continue until the end of the array is reached.

All non-zero elements are shifted forward, and zeroes naturally move to the end.

---

## Example

**Input:**

```
nums = [0, 1, 0, 3, 12]
```

**Output:**

```
[1, 3, 12, 0, 0]
```

---

## Time and Space Complexity

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(1)`

---

## Key Advantages

* No extra space required.
* Stable order of non-zero elements is preserved.
* Efficient and suitable for large inputs.

---

## Exam Tip

If the problem explicitly states **"in-place"** or **"constant extra space"**, this is the preferred solution over auxiliary-array approaches.

---

This is the most efficient and commonly expected solution for the Move Zeroes problem.


# Maximum Subarray Problem – Brute Force and Kadane’s Algorithm (Java)

This document explains two common approaches to solve the **Maximum Subarray** problem:

1. A **brute force approach** using nested loops
2. An **optimized approach using Kadane’s Algorithm**

Both solutions are important from an **exam and interview** perspective.

---

## Problem Statement

Given an integer array `nums`, find the **contiguous subarray** (containing at least one number) which has the **largest sum**, and return that sum.

---

## Approach 1: Brute Force Solution

This approach checks the sum of **all possible subarrays** and keeps track of the maximum sum found.

### Source Code

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int MaxSum = nums[0];
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int sum = 0;
                for (int k = i; k <= j; k++) {
                    sum += nums[k];
                }
                if (sum > MaxSum) {
                    MaxSum = sum;
                }
            }
        }
        return MaxSum;
    }
}
```

### Explanation

* The outer two loops generate all possible subarrays.
* The innermost loop calculates the sum of each subarray.
* `MaxSum` stores the maximum sum encountered.

### Complexity Analysis

* **Time Complexity:** `O(n³)`
* **Space Complexity:** `O(1)`

---

## Approach 2: Kadane’s Algorithm (Optimized)

Kadane’s Algorithm efficiently computes the maximum subarray sum using a **single pass** through the array.

### Source Code

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int MaxSum = nums[0];
        int sumSoFar = 0;
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            sumSoFar += nums[i];

            if (sumSoFar > MaxSum) {
                MaxSum = sumSoFar;
            }

            if (sumSoFar < 0) {
                sumSoFar = 0;
            }
        }
        return MaxSum;
    }
}
```

### Explanation

* `sumSoFar` keeps track of the current subarray sum.
* If `sumSoFar` becomes negative, it is reset to `0`.
* `MaxSum` always stores the maximum subarray sum found so far.

This works because a negative sum will only reduce the value of any future subarray.

### Complexity Analysis

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(1)`

---

## Example

**Input:**

```
nums = [-2,1,-3,4,-1,2,1,-5,4]
```

**Output:**

```
6
```

**Explanation:**
The subarray `[4, -1, 2, 1]` has the maximum sum.

---

## Comparison Summary

| Approach           | Time Complexity | Space Complexity |
| ------------------ | --------------- | ---------------- |
| Brute Force        | O(n³)           | O(1)             |
| Kadane’s Algorithm | O(n)            | O(1)             |

---

## Exam Tip

* Start with the brute force idea to explain your thinking.
* Mention Kadane’s Algorithm as the optimized solution.
* Kadane’s Algorithm is **frequently asked** in coding interviews.

---

This problem is a classic example of how optimization can drastically improve performance.

