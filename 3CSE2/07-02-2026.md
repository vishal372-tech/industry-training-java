# Majority Element – Frequency Array vs Boyer–Moore Algorithm (Java)

This document explains two different approaches to solve the **Majority Element** problem:

1. Using a **frequency array** (counting approach)
2. Using the **Boyer–Moore Voting Algorithm** (optimal approach)

Both approaches are commonly discussed in **DSA classes, exams, and interviews**.

---

## Problem Statement

Given an array `nums` of size `n`, return the **majority element**.

* The majority element is the element that appears **more than ⌊n / 2⌋ times**.
* You may assume that a majority element **always exists** in the array.

---

## Approach 1: Frequency Array Method

This approach counts the frequency of each element and returns the one whose count exceeds `n / 2`.

### Source Code

```java
class Solution {
    public int majorityElement(int[] nums) {
        int Max = nums[0];
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            if (nums[i] > Max)
                Max = nums[i];
        }

        int[] freq = new int[Max + 1];
        for (int i = 0; i < n; i++) {
            int curr = nums[i];
            freq[curr]++;
        }

        for (int i = 0; i < n; i++) {
            if (freq[nums[i]] > n / 2) {
                return nums[i];
            }
        }
        return -1;
    }
}
```

### Explanation

* Find the maximum element to determine the size of the frequency array.
* Count the occurrences of each number.
* Check which element appears more than `n / 2` times.

### Complexity Analysis

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(Max)`

### Limitations

* Works only for **non-negative integers**.
* Not memory efficient if array values are large.

---

## Approach 2: Boyer–Moore Voting Algorithm (Optimized)

This is the **most efficient and expected solution** for the Majority Element problem.

### Source Code

```java
class Solution {
    public int majorityElement(int[] nums) {
        int candidate = -1;
        int count = 0;
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            if (count == 0) {
                candidate = nums[i];
                count = 1;
            } else if (nums[i] != candidate) {
                count--;
            } else {
                count++;
            }
        }
        return candidate;
    }
}
```

### Explanation

* Maintain a `candidate` and a `count`.
* When `count` becomes `0`, choose a new candidate.
* Increment count if the current element matches the candidate.
* Decrement count otherwise.

Since a majority element always exists, the final candidate is guaranteed to be the answer.

### Complexity Analysis

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(1)`

---

## Example

**Input:**

```
nums = [2, 2, 1, 1, 1, 2, 2]
```

**Output:**

```
2
```

---

## Comparison Summary

| Approach        | Time Complexity | Space Complexity |
| --------------- | --------------- | ---------------- |
| Frequency Array | O(n)            | O(Max)           |
| Boyer–Moore     | O(n)            | O(1)             |

---

## Exam Tip

* Frequency method is easy to understand and explain.
* **Boyer–Moore Voting Algorithm** is the preferred answer in interviews.
* Always mention that the majority element is guaranteed to exist.

---

This problem is a classic example of how clever counting logic can eliminate extra space usage.
