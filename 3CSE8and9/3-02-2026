# Aggregation vs Composition in Java

This example demonstrates two important **object-oriented design relationships** in Java:

* **Aggregation (loosely coupled relationship)**
* **Composition (tightly coupled relationship)**

Both are forms of *association*, but they differ in terms of object ownership and lifecycle dependency.

---

## Aggregation (Loosely Coupled)

In aggregation, objects have an independent lifecycle. One object can exist without the other.

### Example: Department and University

```java
// Aggregation or loosely coupled
class Department {
    static String Deptname;

    Department(String name) {
        Deptname = name;
    }
}

class University {
    private Department HR;

    University(Department d) {
        HR = d;
    }

    String getHRValue() {
        return HR.Deptname;
    }
}
```

### Explanation

* `Department` exists independently of `University`.
* `University` **receives** a `Department` object from outside.
* Changes made to `Department` are reflected in `University`.
* This shows a **has-a relationship** with loose coupling.

---

## Composition (Tightly Coupled)

In composition, objects are **strongly dependent** on the container object. If the container is destroyed, the contained objects are also destroyed.

### Example: House and Room

```java
// Composition or tightly coupled
class Room {
    private String name;

    public Room(String name) {
        this.name = name;
    }
}

class House {
    private List<Room> rooms = new ArrayList<>();

    public House() {
        rooms.add(new Room("Living Room")); // Created internally
    }
}
```

### Explanation

* `Room` objects are created **inside** the `House` class.
* `Room` cannot exist independently of `House`.
* This represents **strong ownership** and tight coupling.

---

## Main Method

```java
public class Main {
    public static void main(String[] args) {
        Department d = new Department("HR");
        University u = new University(d);

        System.out.println(u.getHRValue());

        Department.Deptname = "Sales";
        System.out.println(u.getHRValue());
    }
}
```

---

## Output

```
HR
Sales
```

---

## Key Differences

| Feature              | Aggregation       | Composition      |
| -------------------- | ----------------- | ---------------- |
| Coupling             | Loose             | Tight            |
| Object Creation      | Outside the class | Inside the class |
| Lifecycle Dependency | Independent       | Dependent        |
| Relationship Type    | Has-a             | Part-of          |

---

## Conclusion

* Use **aggregation** when objects can exist independently.
* Use **composition** when objects are an essential part of another object.
* Composition is generally preferred for stronger encapsulation and safer design.

---

This distinction is frequently asked in exams and commonly used in real-world system design.

# Nested Loop with Non-Linear Increment in Java

This example demonstrates a **nested loop** where the inner loop does **not increment linearly**. Such patterns are commonly used to explain **time complexity analysis** in Java and DSA.

---

## Source Code

```java
for (int i = 0; i < n; i++) {
    for (int j = 2; j < n; j = j * j) {
        // loop body
    }
}
```

---

## Loop Breakdown

### Outer Loop

```java
for (int i = 0; i < n; i++)
```

* Starts from `i = 0`
* Runs until `i < n`
* Executes **n times**

---

### Inner Loop

```java
for (int j = 2; j < n; j = j * j)
```

* Starts from `j = 2`
* In each iteration, `j` is squared (`j = j * j`)
* Values of `j` grow very fast:

  * 2 → 4 → 16 → 256 → ...
* The loop runs approximately **log log n** times

---

## Time Complexity Analysis

* Outer loop runs **n** times
* Inner loop runs **log log n** times

### Overall Time Complexity

```
O(n log log n)
```

---

## Why `log log n`?

Since `j` is squared every iteration:

* After 1st iteration: `j = 2²`
* After 2nd iteration: `j = 2⁴`
* After 3rd iteration: `j = 2⁸`

The loop stops when `j ≥ n`, which happens after roughly `log log n` steps.

---

## Key Observations

* This is **not** a simple nested loop with `O(n²)` complexity.
* Faster growth in loop variables reduces the number of iterations.
* Such patterns are important in competitive programming and interviews.

---

## Exam Tip

If you see:

```java
j = j * j
```

Always think in terms of **log log n**, not `log n` or `n`.

---

This pattern is frequently used to test understanding of advanced loop analysis.

# `for` Loop with Quadratic Condition in Java

This example demonstrates a `for` loop where the **loop condition depends on the square of the loop variable**. Such loops are commonly analyzed in **time complexity questions**.

---

## Source Code

```java
for (int i = 0; i * i < n; i++) {
    // loop body
}
```

---

## Loop Explanation

* The loop starts with `i = 0`.
* Before every iteration, the condition `i * i < n` is checked.
* The loop continues as long as the **square of `i`** is less than `n`.
* In each iteration, `i` is incremented by 1.

---

## How Many Times Does the Loop Run?

The loop stops when:

```
i * i ≥ n
```

This means:

```
i ≥ √n
```

So, the loop runs approximately **√n times**.

---

## Time Complexity

```
O(√n)
```

---

## Key Points

* The loop does **not** run `n` times.
* Growth is slower due to the squared condition.
* Commonly seen in **prime checking**, **factor finding**, and **optimization problems**.

---

## Exam Tip

Whenever you see:

```java
i * i < n
```

Think immediately:

```
O(√n)
```

---

This pattern is frequently used to test understanding of loop behavior and complexity analysis.
