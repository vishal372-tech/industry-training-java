# Abstract Class Example: Bank Accounts in Java

This example demonstrates the use of an **abstract class** in Java to model different types of bank accounts. It shows how common data and behavior can be defined in a base class, while specific logic is implemented by derived classes.

---

## Problem Overview

We want to model different bank account types:

* A generic `Account` that holds common details.
* A `FixDeposit` account that calculates interest based on principal, rate, and duration.
* A `RecurringDeposit` account that calculates interest based on monthly deposits.

Each account type calculates interest differently, so the interest calculation is kept **abstract** in the base class.

---

## Source Code

```java
abstract class Account {
    String AccountHolder;
    int PrincipalAmt;

    Account(String AccountHolder, int PrincipalAmt) {
        this.AccountHolder = AccountHolder;
        this.PrincipalAmt = PrincipalAmt;
    }

    abstract double calculateInterest();
}

class FixDeposit extends Account {
    int RateOfInterest;
    int Duration;

    FixDeposit(String AccountHolder, int PrincipalAmt, int RateOfInterest, int Duration) {
        super(AccountHolder, PrincipalAmt);
        this.RateOfInterest = RateOfInterest;
        this.Duration = Duration;
    }

    double calculateInterest() {
        return (PrincipalAmt * RateOfInterest * Duration) / 100;
    }
}

class RecurringDeposit extends Account {
    int MaturityAmt;
    int Duration;
    int RateOfInterest;
    int MonthlyDeposit;

    RecurringDeposit(String AccountHolder, int PrincipalAmt, int Duration, int RateOfInterest, int MonthlyDeposit) {
        super(AccountHolder, PrincipalAmt);
        this.Duration = Duration;
        this.RateOfInterest = RateOfInterest;
        this.MonthlyDeposit = MonthlyDeposit;
        this.MaturityAmt = MonthlyDeposit * Duration;
    }

    double calculateInterest() {
        return (MaturityAmt * Duration * RateOfInterest) / 1200;
    }
}

class Main {
    public static void main(String[] args) {
        FixDeposit cus1 = new FixDeposit("Vishal", 1000, 12, 12);
        System.out.println(cus1.calculateInterest());

        RecurringDeposit cus2 = new RecurringDeposit("Chaman", 1000, 12, 12, 100);
        System.out.println(cus2.calculateInterest());
    }
}
```

---

## Explanation

### 1. `Account` (Abstract Class)

* Stores common data such as `AccountHolder` and `PrincipalAmt`.
* Contains an **abstract method** `calculateInterest()`.
* Cannot be instantiated directly.

### 2. `FixDeposit` Class

* Extends `Account`.
* Adds `RateOfInterest` and `Duration`.
* Provides its own implementation of `calculateInterest()`.

### 3. `RecurringDeposit` Class

* Extends `Account`.
* Calculates maturity amount using monthly deposits.
* Overrides `calculateInterest()` with its own formula.

### 4. `Main` Class

* Creates objects of both derived classes.
* Demonstrates **runtime polymorphism** by calling `calculateInterest()`.

---

## Output

```
1440.0
144.0
```

---

## Key Concepts Used

* Abstract class
* Constructor chaining using `super`
* Method overriding
* Runtime polymorphism
* Code reuse through inheritance

---

This design is commonly used in real-world applications where multiple subclasses share common structure but differ in behavior.