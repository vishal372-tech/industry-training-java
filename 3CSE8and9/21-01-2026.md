# Method Overloading Example in Java

This example demonstrates **method overloading** in Java, where multiple methods share the same name but differ in the number of parameters. Java determines which method to call based on the arguments provided.

---

## Java Code Example

```java
class Demo {
    void multiply(int a, int b) {
        System.out.println("Result is " + (a * b));
    }
    void multiply(int a, int b, int c) {
        System.out.println("Result is " + (a * b * c));
    }
    public static void main(String[] args) {
        Demo obj = new Demo();
        obj.multiply(8, 5);
        obj.multiply(4, 6, 2);
    }
}
```

---

## Explanation

### 1. What Is Method Overloading?

Method overloading allows a class to have **multiple methods with the same name** as long as their parameter lists are different. This improves readability and logical grouping of similar operations.

### 2. Overloaded `multiply` Methods

```java
void multiply(int a, int b)
void multiply(int a, int b, int c)
```

* Both methods perform multiplication.
* The first method accepts two parameters.
* The second method accepts three parameters.

Java selects the correct method at **compile time** based on the number of arguments passed.

### 3. Method Calls

```java
obj.multiply(8, 5);
obj.multiply(4, 6, 2);
```

* The first call invokes the two-parameter method.
* The second call invokes the three-parameter method.

---

## Key Points

* Method overloading is a form of **compile-time polymorphism**.
* Methods must differ in **parameter count or parameter type**.
* Return type alone cannot be used to overload a method.

Method overloading makes code cleaner and easier to understand when performing similar operations.

# Default and Parameterized Constructor Example in Java

This example demonstrates the use of **both default and parameterized constructors** in Java. It shows how objects can be initialized in different ways depending on the constructor used.

---

## Java Code Example

```java
public class Main {
    int id;
    String name;

    public Main() {
        System.out.println("This is a default constructor");
    }
    public Main(int i, String n) {
        id = i;
        name = n;
    }
    public static void main(String[] args) {
        Main s = new Main();
        System.out.println("\nDefault Constructor values: \n");
        System.out.println("Student Id : " + s.id + "\nStudent Name : "
                + s.name);
        System.out.println("\nParameterized Constructor values: \n");
        Main student = new Main(10, "David");
        System.out.println("Student Id : " + student.id + "\nStudent Name : "
                + student.name);
    }
}
```

---

## Explanation

### 1. Instance Variables

* `id` and `name` are instance variables of the class.
* If not explicitly initialized, they take default values (`0` for `int`, `null` for `String`).

### 2. Default Constructor

```java
public Main()
```

* This constructor takes no parameters.
* It is called when an object is created without passing any values.
* In this example, it only prints a message and does not initialize variables explicitly.

### 3. Parameterized Constructor

```java
public Main(int i, String n)
```

* This constructor accepts values as parameters.
* It initializes the object with the provided `id` and `name`.

### 4. Object Creation and Output

* `new Main()` calls the default constructor.
* `new Main(10, "David")` calls the parameterized constructor.

The output clearly shows how different constructors affect object initialization.

---

## Key Concepts Covered

* Default constructor
* Parameterized constructor
* Constructor overloading
* Default values of instance variables

Using multiple constructors provides flexibility while creating objects in Java programs.

# Method Overloading with Different Data Types in Java

This example demonstrates **method overloading using different parameter data types** in Java. It shows how Java selects the appropriate method based on the type of arguments passed.

---

## Java Code Example

```java
class Sum {
    static int add(int a, int b) {
        return a + b;
    }
    static double add(double a, double b) {
        return a + b;
    }
}
class TestOverloading2 {
    public static void main(String[] args) {
        System.out.println(Sum.add(17, 13));
        System.out.println(Sum.add(10.4, 10.6));
    }
}
```

---

## Explanation

### 1. Method Overloading

Method overloading allows multiple methods to have the **same name** but different parameter lists. In this case, both methods are named `add`, but they differ in parameter data types.

### 2. Overloaded `add` Methods

```java
static int add(int a, int b)
static double add(double a, double b)
```

* The first method handles integer addition.
* The second method handles decimal (double) addition.

Java determines which method to call at **compile time** based on the argument types.

### 3. Static Method Calls

```java
Sum.add(17, 13);
Sum.add(10.4, 10.6);
```

* Since the methods are `static`, they are called using the class name.
* No object creation is required.

---

## Key Points

* Method overloading can be done using **different data types**.
* It is an example of **compile-time polymorphism**.
* Static methods belong to the class, not to objects.

This approach improves code readability while allowing similar operations to be grouped under a single method name.

# Method Overloading with Different Numeric Types in Java

This example demonstrates **method overloading** by using the same method name with **different parameter data types**. Java decides which method to execute based on the type of argument passed during the method call.

---

## Java Code Example

```java
public void Square(int number) {
    int square = number * number;
    System.out.println("Method with Integer Argument Called: " + square);
}

public void Square(double number) {
    double square = number * number;
    System.out.println("Method with double Argument Called: " + square);
}

public void Square(long number) {
    long square = number * number;
    System.out.println("Method with long Argument Called: " + square);
}
```

---

## Explanation

### 1. What Is Method Overloading?

Method overloading allows multiple methods to have the **same name** but different parameter lists. The difference can be in:

* Number of parameters
* Data types of parameters
* Order of parameters

### 2. Overloaded `Square` Methods

```java
Square(int number)
Square(double number)
Square(long number)
```

* Each method calculates the square of a number.
* The method executed depends on the **data type of the argument** passed.

For example:

* Passing an `int` value calls `Square(int)`
* Passing a `double` value calls `Square(double)`
* Passing a `long` value calls `Square(long)`

### 3. Compile-Time Decision

Java resolves method overloading at **compile time**, which is why it is also known as **compile-time polymorphism**.

---

## Key Points

* Method overloading improves code readability and reuse.
* Methods must differ in parameter list, not just return type.
* Java automatically selects the most appropriate method based on argument type.

